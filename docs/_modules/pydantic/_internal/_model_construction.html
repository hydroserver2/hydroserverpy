<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pydantic._internal._model_construction &mdash; hydroserverpy  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../../_static/autodoc_pydantic.css?v=a0a71c94" />

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../_static/documentation_options.js?v=5929fcd5"></script>
        <script src="../../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            hydroserverpy
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../hydroserverpy.html">hydroserverpy package</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">hydroserverpy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">pydantic._internal._model_construction</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pydantic._internal._model_construction</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Private logic for creating models.&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span> <span class="k">as</span> <span class="n">_annotations</span>

<span class="kn">import</span> <span class="nn">builtins</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">typing</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">weakref</span>
<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABCMeta</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="n">FunctionType</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Generic</span><span class="p">,</span> <span class="n">NoReturn</span>

<span class="kn">import</span> <span class="nn">typing_extensions</span>
<span class="kn">from</span> <span class="nn">pydantic_core</span> <span class="kn">import</span> <span class="n">PydanticUndefined</span><span class="p">,</span> <span class="n">SchemaSerializer</span>
<span class="kn">from</span> <span class="nn">typing_extensions</span> <span class="kn">import</span> <span class="n">dataclass_transform</span><span class="p">,</span> <span class="n">deprecated</span>

<span class="kn">from</span> <span class="nn">..errors</span> <span class="kn">import</span> <span class="n">PydanticUndefinedAnnotation</span><span class="p">,</span> <span class="n">PydanticUserError</span>
<span class="kn">from</span> <span class="nn">..plugin._schema_validator</span> <span class="kn">import</span> <span class="n">create_schema_validator</span>
<span class="kn">from</span> <span class="nn">..warnings</span> <span class="kn">import</span> <span class="n">GenericBeforeBaseModelWarning</span><span class="p">,</span> <span class="n">PydanticDeprecatedSince20</span>
<span class="kn">from</span> <span class="nn">._config</span> <span class="kn">import</span> <span class="n">ConfigWrapper</span>
<span class="kn">from</span> <span class="nn">._decorators</span> <span class="kn">import</span> <span class="n">DecoratorInfos</span><span class="p">,</span> <span class="n">PydanticDescriptorProxy</span><span class="p">,</span> <span class="n">get_attribute_from_bases</span><span class="p">,</span> <span class="n">unwrap_wrapped_function</span>
<span class="kn">from</span> <span class="nn">._fields</span> <span class="kn">import</span> <span class="n">collect_model_fields</span><span class="p">,</span> <span class="n">is_valid_field_name</span><span class="p">,</span> <span class="n">is_valid_privateattr_name</span>
<span class="kn">from</span> <span class="nn">._generate_schema</span> <span class="kn">import</span> <span class="n">GenerateSchema</span>
<span class="kn">from</span> <span class="nn">._generics</span> <span class="kn">import</span> <span class="n">PydanticGenericMetadata</span><span class="p">,</span> <span class="n">get_model_typevars_map</span>
<span class="kn">from</span> <span class="nn">._mock_val_ser</span> <span class="kn">import</span> <span class="n">MockValSer</span><span class="p">,</span> <span class="n">set_model_mocks</span>
<span class="kn">from</span> <span class="nn">._schema_generation_shared</span> <span class="kn">import</span> <span class="n">CallbackGetCoreSchemaHandler</span>
<span class="kn">from</span> <span class="nn">._signature</span> <span class="kn">import</span> <span class="n">generate_pydantic_signature</span>
<span class="kn">from</span> <span class="nn">._typing_extra</span> <span class="kn">import</span> <span class="n">get_cls_types_namespace</span><span class="p">,</span> <span class="n">is_annotated</span><span class="p">,</span> <span class="n">is_classvar</span><span class="p">,</span> <span class="n">parent_frame_namespace</span>
<span class="kn">from</span> <span class="nn">._utils</span> <span class="kn">import</span> <span class="n">ClassAttribute</span><span class="p">,</span> <span class="n">SafeGetItemProxy</span>
<span class="kn">from</span> <span class="nn">._validate_call</span> <span class="kn">import</span> <span class="n">ValidateCallWrapper</span>

<span class="k">if</span> <span class="n">typing</span><span class="o">.</span><span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">..fields</span> <span class="kn">import</span> <span class="n">Field</span> <span class="k">as</span> <span class="n">PydanticModelField</span>
    <span class="kn">from</span> <span class="nn">..fields</span> <span class="kn">import</span> <span class="n">FieldInfo</span><span class="p">,</span> <span class="n">ModelPrivateAttr</span>
    <span class="kn">from</span> <span class="nn">..main</span> <span class="kn">import</span> <span class="n">BaseModel</span>
<span class="k">else</span><span class="p">:</span>
    <span class="c1"># See PyCharm issues https://youtrack.jetbrains.com/issue/PY-21915</span>
    <span class="c1"># and https://youtrack.jetbrains.com/issue/PY-51428</span>
    <span class="ne">DeprecationWarning</span> <span class="o">=</span> <span class="n">PydanticDeprecatedSince20</span>
    <span class="n">PydanticModelField</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>

<span class="n">object_setattr</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span>


<span class="k">class</span> <span class="nc">_ModelNamespaceDict</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A dictionary subclass that intercepts attribute setting on model classes and</span>
<span class="sd">    warns about overriding of decorators.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">existing</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">existing</span> <span class="ow">and</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">existing</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">existing</span><span class="p">,</span> <span class="n">PydanticDescriptorProxy</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;`</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s1">` overrides an existing Pydantic `</span><span class="si">{</span><span class="n">existing</span><span class="o">.</span><span class="n">decorator_info</span><span class="o">.</span><span class="n">decorator_repr</span><span class="si">}</span><span class="s1">` decorator&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>


<span class="nd">@dataclass_transform</span><span class="p">(</span><span class="n">kw_only_default</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">field_specifiers</span><span class="o">=</span><span class="p">(</span><span class="n">PydanticModelField</span><span class="p">,))</span>
<span class="k">class</span> <span class="nc">ModelMetaclass</span><span class="p">(</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span>
        <span class="n">mcs</span><span class="p">,</span>
        <span class="n">cls_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">bases</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">type</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="o">...</span><span class="p">],</span>
        <span class="n">namespace</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
        <span class="n">__pydantic_generic_metadata__</span><span class="p">:</span> <span class="n">PydanticGenericMetadata</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">__pydantic_reset_parent_namespace__</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">_create_model_module</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">type</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Metaclass for creating Pydantic models.</span>

<span class="sd">        Args:</span>
<span class="sd">            cls_name: The name of the class to be created.</span>
<span class="sd">            bases: The base classes of the class to be created.</span>
<span class="sd">            namespace: The attribute dictionary of the class to be created.</span>
<span class="sd">            __pydantic_generic_metadata__: Metadata for generic models.</span>
<span class="sd">            __pydantic_reset_parent_namespace__: Reset parent namespace.</span>
<span class="sd">            _create_model_module: The module of the class to be created, if created by `create_model`.</span>
<span class="sd">            **kwargs: Catch-all for any other keyword arguments.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The new class created by the metaclass.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Note `ModelMetaclass` refers to `BaseModel`, but is also used to *create* `BaseModel`, so we rely on the fact</span>
        <span class="c1"># that `BaseModel` itself won&#39;t have any bases, but any subclass of it will, to determine whether the `__new__`</span>
        <span class="c1"># call we&#39;re in the middle of is for the `BaseModel` class.</span>
        <span class="k">if</span> <span class="n">bases</span><span class="p">:</span>
            <span class="n">base_field_names</span><span class="p">,</span> <span class="n">class_vars</span><span class="p">,</span> <span class="n">base_private_attributes</span> <span class="o">=</span> <span class="n">mcs</span><span class="o">.</span><span class="n">_collect_bases_data</span><span class="p">(</span><span class="n">bases</span><span class="p">)</span>

            <span class="n">config_wrapper</span> <span class="o">=</span> <span class="n">ConfigWrapper</span><span class="o">.</span><span class="n">for_model</span><span class="p">(</span><span class="n">bases</span><span class="p">,</span> <span class="n">namespace</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
            <span class="n">namespace</span><span class="p">[</span><span class="s1">&#39;model_config&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">config_wrapper</span><span class="o">.</span><span class="n">config_dict</span>
            <span class="n">private_attributes</span> <span class="o">=</span> <span class="n">inspect_namespace</span><span class="p">(</span>
                <span class="n">namespace</span><span class="p">,</span> <span class="n">config_wrapper</span><span class="o">.</span><span class="n">ignored_types</span><span class="p">,</span> <span class="n">class_vars</span><span class="p">,</span> <span class="n">base_field_names</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">private_attributes</span> <span class="ow">or</span> <span class="n">base_private_attributes</span><span class="p">:</span>
                <span class="n">original_model_post_init</span> <span class="o">=</span> <span class="n">get_model_post_init</span><span class="p">(</span><span class="n">namespace</span><span class="p">,</span> <span class="n">bases</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">original_model_post_init</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># if there are private_attributes and a model_post_init function, we handle both</span>

                    <span class="k">def</span> <span class="nf">wrapped_model_post_init</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">BaseModel</span><span class="p">,</span> <span class="n">__context</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">                        </span><span class="sd">&quot;&quot;&quot;We need to both initialize private attributes and call the user-defined model_post_init</span>
<span class="sd">                        method.</span>
<span class="sd">                        &quot;&quot;&quot;</span>
                        <span class="n">init_private_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">__context</span><span class="p">)</span>
                        <span class="n">original_model_post_init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">__context</span><span class="p">)</span>

                    <span class="n">namespace</span><span class="p">[</span><span class="s1">&#39;model_post_init&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">wrapped_model_post_init</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">namespace</span><span class="p">[</span><span class="s1">&#39;model_post_init&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">init_private_attributes</span>

            <span class="n">namespace</span><span class="p">[</span><span class="s1">&#39;__class_vars__&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">class_vars</span>
            <span class="n">namespace</span><span class="p">[</span><span class="s1">&#39;__private_attributes__&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">base_private_attributes</span><span class="p">,</span> <span class="o">**</span><span class="n">private_attributes</span><span class="p">}</span>

            <span class="bp">cls</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">BaseModel</span><span class="p">]</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">cls_name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">namespace</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>  <span class="c1"># type: ignore</span>

            <span class="kn">from</span> <span class="nn">..main</span> <span class="kn">import</span> <span class="n">BaseModel</span>

            <span class="n">mro</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__mro__</span>
            <span class="k">if</span> <span class="n">Generic</span> <span class="ow">in</span> <span class="n">mro</span> <span class="ow">and</span> <span class="n">mro</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">Generic</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">mro</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="n">GenericBeforeBaseModelWarning</span><span class="p">(</span>
                        <span class="s1">&#39;Classes should inherit from `BaseModel` before generic classes (e.g. `typing.Generic[T]`) &#39;</span>
                        <span class="s1">&#39;for pydantic generics to work properly.&#39;</span>
                    <span class="p">),</span>
                    <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="bp">cls</span><span class="o">.</span><span class="n">__pydantic_custom_init__</span> <span class="o">=</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="fm">__init__</span><span class="p">,</span> <span class="s1">&#39;__pydantic_base_init__&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">__pydantic_post_init__</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">model_post_init</span> <span class="ow">is</span> <span class="n">BaseModel</span><span class="o">.</span><span class="n">model_post_init</span> <span class="k">else</span> <span class="s1">&#39;model_post_init&#39;</span>

            <span class="bp">cls</span><span class="o">.</span><span class="n">__pydantic_decorators__</span> <span class="o">=</span> <span class="n">DecoratorInfos</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

            <span class="c1"># Use the getattr below to grab the __parameters__ from the `typing.Generic` parent class</span>
            <span class="k">if</span> <span class="n">__pydantic_generic_metadata__</span><span class="p">:</span>
                <span class="bp">cls</span><span class="o">.</span><span class="n">__pydantic_generic_metadata__</span> <span class="o">=</span> <span class="n">__pydantic_generic_metadata__</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">parent_parameters</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;__pydantic_generic_metadata__&#39;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;parameters&#39;</span><span class="p">,</span> <span class="p">())</span>
                <span class="n">parameters</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;__parameters__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="n">parent_parameters</span>
                <span class="k">if</span> <span class="n">parameters</span> <span class="ow">and</span> <span class="n">parent_parameters</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span> <span class="ow">in</span> <span class="n">parameters</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">parent_parameters</span><span class="p">):</span>
                    <span class="kn">from</span> <span class="nn">..root_model</span> <span class="kn">import</span> <span class="n">RootModelRootType</span>

                    <span class="n">missing_parameters</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">parameters</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">parent_parameters</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">RootModelRootType</span> <span class="ow">in</span> <span class="n">parent_parameters</span> <span class="ow">and</span> <span class="n">RootModelRootType</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">:</span>
                        <span class="c1"># This is a special case where the user has subclassed `RootModel`, but has not parametrized</span>
                        <span class="c1"># RootModel with the generic type identifiers being used. Ex:</span>
                        <span class="c1"># class MyModel(RootModel, Generic[T]):</span>
                        <span class="c1">#    root: T</span>
                        <span class="c1"># Should instead just be:</span>
                        <span class="c1"># class MyModel(RootModel[T]):</span>
                        <span class="c1">#   root: T</span>
                        <span class="n">parameters_str</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">missing_parameters</span><span class="p">])</span>
                        <span class="n">error_message</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1"> is a subclass of `RootModel`, but does not include the generic type identifier(s) &#39;</span>
                            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">parameters_str</span><span class="si">}</span><span class="s1"> in its parameters. &#39;</span>
                            <span class="sa">f</span><span class="s1">&#39;You should parametrize RootModel directly, e.g., `class </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">(RootModel[</span><span class="si">{</span><span class="n">parameters_str</span><span class="si">}</span><span class="s1">]): ...`.&#39;</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">combined_parameters</span> <span class="o">=</span> <span class="n">parent_parameters</span> <span class="o">+</span> <span class="n">missing_parameters</span>
                        <span class="n">parameters_str</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">combined_parameters</span><span class="p">])</span>
                        <span class="n">generic_type_label</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;typing.Generic[</span><span class="si">{</span><span class="n">parameters_str</span><span class="si">}</span><span class="s1">]&#39;</span>
                        <span class="n">error_message</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="sa">f</span><span class="s1">&#39;All parameters must be present on typing.Generic;&#39;</span>
                            <span class="sa">f</span><span class="s1">&#39; you should inherit from </span><span class="si">{</span><span class="n">generic_type_label</span><span class="si">}</span><span class="s1">.&#39;</span>
                        <span class="p">)</span>
                        <span class="k">if</span> <span class="n">Generic</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
                            <span class="c1"># We raise an error here not because it is desirable, but because some cases are mishandled.</span>
                            <span class="c1"># It would be nice to remove this error and still have things behave as expected, it&#39;s just</span>
                            <span class="c1"># challenging because we are using a custom `__class_getitem__` to parametrize generic models,</span>
                            <span class="c1"># and not returning a typing._GenericAlias from it.</span>
                            <span class="n">bases_str</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">generic_type_label</span><span class="p">])</span>
                            <span class="n">error_message</span> <span class="o">+=</span> <span class="p">(</span>
                                <span class="sa">f</span><span class="s1">&#39; Note: `typing.Generic` must go last: `class </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">(</span><span class="si">{</span><span class="n">bases_str</span><span class="si">}</span><span class="s1">): ...`)&#39;</span>
                            <span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">error_message</span><span class="p">)</span>

                <span class="bp">cls</span><span class="o">.</span><span class="n">__pydantic_generic_metadata__</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;origin&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="s1">&#39;args&#39;</span><span class="p">:</span> <span class="p">(),</span>
                    <span class="s1">&#39;parameters&#39;</span><span class="p">:</span> <span class="n">parameters</span><span class="p">,</span>
                <span class="p">}</span>

            <span class="bp">cls</span><span class="o">.</span><span class="n">__pydantic_complete__</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># Ensure this specific class gets completed</span>

            <span class="c1"># preserve `__set_name__` protocol defined in https://peps.python.org/pep-0487</span>
            <span class="c1"># for attributes not in `new_namespace` (e.g. private attributes)</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">private_attributes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">__set_name__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">__pydantic_reset_parent_namespace__</span><span class="p">:</span>
                <span class="bp">cls</span><span class="o">.</span><span class="n">__pydantic_parent_namespace__</span> <span class="o">=</span> <span class="n">build_lenient_weakvaluedict</span><span class="p">(</span><span class="n">parent_frame_namespace</span><span class="p">())</span>
            <span class="n">parent_namespace</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;__pydantic_parent_namespace__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parent_namespace</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">parent_namespace</span> <span class="o">=</span> <span class="n">unpack_lenient_weakvaluedict</span><span class="p">(</span><span class="n">parent_namespace</span><span class="p">)</span>

            <span class="n">types_namespace</span> <span class="o">=</span> <span class="n">get_cls_types_namespace</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">parent_namespace</span><span class="p">)</span>
            <span class="n">set_model_fields</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">config_wrapper</span><span class="p">,</span> <span class="n">types_namespace</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">config_wrapper</span><span class="o">.</span><span class="n">frozen</span> <span class="ow">and</span> <span class="s1">&#39;__hash__&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">namespace</span><span class="p">:</span>
                <span class="n">set_default_hash_func</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">bases</span><span class="p">)</span>

            <span class="n">complete_model_class</span><span class="p">(</span>
                <span class="bp">cls</span><span class="p">,</span>
                <span class="n">cls_name</span><span class="p">,</span>
                <span class="n">config_wrapper</span><span class="p">,</span>
                <span class="n">raise_errors</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">types_namespace</span><span class="o">=</span><span class="n">types_namespace</span><span class="p">,</span>
                <span class="n">create_model_module</span><span class="o">=</span><span class="n">_create_model_module</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># If this is placed before the complete_model_class call above,</span>
            <span class="c1"># the generic computed fields return type is set to PydanticUndefined</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">model_computed_fields</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">info</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__pydantic_decorators__</span><span class="o">.</span><span class="n">computed_fields</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

            <span class="n">set_deprecated_descriptors</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

            <span class="c1"># using super(cls, cls) on the next line ensures we only call the parent class&#39;s __pydantic_init_subclass__</span>
            <span class="c1"># I believe the `type: ignore` is only necessary because mypy doesn&#39;t realize that this code branch is</span>
            <span class="c1"># only hit for _proper_ subclasses of BaseModel</span>
            <span class="nb">super</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="n">__pydantic_init_subclass__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>  <span class="c1"># type: ignore[misc]</span>
            <span class="k">return</span> <span class="bp">cls</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># this is the BaseModel class itself being created, no logic required</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">cls_name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">namespace</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">typing</span><span class="o">.</span><span class="n">TYPE_CHECKING</span><span class="p">:</span>  <span class="c1"># pragma: no branch</span>
        <span class="c1"># We put `__getattr__` in a non-TYPE_CHECKING block because otherwise, mypy allows arbitrary attribute access</span>

        <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;This is necessary to keep attribute access working for class attribute access.&quot;&quot;&quot;</span>
            <span class="n">private_attributes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__private_attributes__&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">private_attributes</span> <span class="ow">and</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">private_attributes</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">private_attributes</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">item</span> <span class="o">==</span> <span class="s1">&#39;__pydantic_core_schema__&#39;</span><span class="p">:</span>
                <span class="c1"># This means the class didn&#39;t get a schema generated for it, likely because there was an undefined reference</span>
                <span class="n">maybe_mock_validator</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;__pydantic_validator__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">maybe_mock_validator</span><span class="p">,</span> <span class="n">MockValSer</span><span class="p">):</span>
                    <span class="n">rebuilt_validator</span> <span class="o">=</span> <span class="n">maybe_mock_validator</span><span class="o">.</span><span class="n">rebuild</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">rebuilt_validator</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="c1"># In this case, a validator was built, and so `__pydantic_core_schema__` should now be set</span>
                        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;__pydantic_core_schema__&#39;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="fm">__prepare__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">object</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">_ModelNamespaceDict</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__instancecheck__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Avoid calling ABC _abc_subclasscheck unless we&#39;re pretty sure.</span>

<span class="sd">        See #3829 and python/cpython#92810</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="s1">&#39;__pydantic_validator__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__instancecheck__</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_collect_bases_data</span><span class="p">(</span><span class="n">bases</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">type</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="o">...</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">ModelPrivateAttr</span><span class="p">]]:</span>
        <span class="kn">from</span> <span class="nn">..main</span> <span class="kn">import</span> <span class="n">BaseModel</span>

        <span class="n">field_names</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">class_vars</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">private_attributes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">ModelPrivateAttr</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">BaseModel</span><span class="p">)</span> <span class="ow">and</span> <span class="n">base</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">BaseModel</span><span class="p">:</span>
                <span class="c1"># model_fields might not be defined yet in the case of generics, so we use getattr here:</span>
                <span class="n">field_names</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="s1">&#39;model_fields&#39;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="n">class_vars</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">__class_vars__</span><span class="p">)</span>
                <span class="n">private_attributes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">__private_attributes__</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">field_names</span><span class="p">,</span> <span class="n">class_vars</span><span class="p">,</span> <span class="n">private_attributes</span>

    <span class="nd">@property</span>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="s1">&#39;The `__fields__` attribute is deprecated, use `model_fields` instead.&#39;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__fields__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">FieldInfo</span><span class="p">]:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s1">&#39;The `__fields__` attribute is deprecated, use `model_fields` instead.&#39;</span><span class="p">,</span> <span class="n">PydanticDeprecatedSince20</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_fields</span>  <span class="c1"># type: ignore</span>

    <span class="k">def</span> <span class="fm">__dir__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="n">attributes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__dir__</span><span class="p">())</span>
        <span class="k">if</span> <span class="s1">&#39;__fields__&#39;</span> <span class="ow">in</span> <span class="n">attributes</span><span class="p">:</span>
            <span class="n">attributes</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;__fields__&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">attributes</span>


<span class="k">def</span> <span class="nf">init_private_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">BaseModel</span><span class="p">,</span> <span class="n">__context</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This function is meant to behave like a BaseModel method to initialise private attributes.</span>

<span class="sd">    It takes context as an argument since that&#39;s what pydantic-core passes when calling it.</span>

<span class="sd">    Args:</span>
<span class="sd">        self: The BaseModel instance.</span>
<span class="sd">        __context: The context.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;__pydantic_private__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">pydantic_private</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">private_attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__private_attributes__</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">default</span> <span class="o">=</span> <span class="n">private_attr</span><span class="o">.</span><span class="n">get_default</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">PydanticUndefined</span><span class="p">:</span>
                <span class="n">pydantic_private</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">default</span>
        <span class="n">object_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;__pydantic_private__&#39;</span><span class="p">,</span> <span class="n">pydantic_private</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">get_model_post_init</span><span class="p">(</span><span class="n">namespace</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="n">bases</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">type</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="o">...</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the `model_post_init` method from the namespace or the class bases, or `None` if not defined.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s1">&#39;model_post_init&#39;</span> <span class="ow">in</span> <span class="n">namespace</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">namespace</span><span class="p">[</span><span class="s1">&#39;model_post_init&#39;</span><span class="p">]</span>

    <span class="kn">from</span> <span class="nn">..main</span> <span class="kn">import</span> <span class="n">BaseModel</span>

    <span class="n">model_post_init</span> <span class="o">=</span> <span class="n">get_attribute_from_bases</span><span class="p">(</span><span class="n">bases</span><span class="p">,</span> <span class="s1">&#39;model_post_init&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">model_post_init</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">BaseModel</span><span class="o">.</span><span class="n">model_post_init</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">model_post_init</span>


<span class="k">def</span> <span class="nf">inspect_namespace</span><span class="p">(</span>  <span class="c1"># noqa C901</span>
    <span class="n">namespace</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
    <span class="n">ignored_types</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">type</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="o">...</span><span class="p">],</span>
    <span class="n">base_class_vars</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="n">base_class_fields</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">ModelPrivateAttr</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Iterate over the namespace and:</span>
<span class="sd">    * gather private attributes</span>
<span class="sd">    * check for items which look like fields but are not (e.g. have no annotation) and warn.</span>

<span class="sd">    Args:</span>
<span class="sd">        namespace: The attribute dictionary of the class to be created.</span>
<span class="sd">        ignored_types: A tuple of ignore types.</span>
<span class="sd">        base_class_vars: A set of base class class variables.</span>
<span class="sd">        base_class_fields: A set of base class fields.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A dict contains private attributes info.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If there is a `__root__` field in model.</span>
<span class="sd">        NameError: If private attribute name is invalid.</span>
<span class="sd">        PydanticUserError:</span>
<span class="sd">            - If a field does not have a type annotation.</span>
<span class="sd">            - If a field on base class was overridden by a non-annotated attribute.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">..fields</span> <span class="kn">import</span> <span class="n">FieldInfo</span><span class="p">,</span> <span class="n">ModelPrivateAttr</span><span class="p">,</span> <span class="n">PrivateAttr</span>

    <span class="n">all_ignored_types</span> <span class="o">=</span> <span class="n">ignored_types</span> <span class="o">+</span> <span class="n">default_ignored_types</span><span class="p">()</span>

    <span class="n">private_attributes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">ModelPrivateAttr</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">raw_annotations</span> <span class="o">=</span> <span class="n">namespace</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__annotations__&#39;</span><span class="p">,</span> <span class="p">{})</span>

    <span class="k">if</span> <span class="s1">&#39;__root__&#39;</span> <span class="ow">in</span> <span class="n">raw_annotations</span> <span class="ow">or</span> <span class="s1">&#39;__root__&#39;</span> <span class="ow">in</span> <span class="n">namespace</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;To define root models, use `pydantic.RootModel` rather than a field called &#39;__root__&#39;&quot;</span><span class="p">)</span>

    <span class="n">ignored_names</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">namespace</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
        <span class="k">if</span> <span class="n">var_name</span> <span class="o">==</span> <span class="s1">&#39;model_config&#39;</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">elif</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">value</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">==</span> <span class="n">namespace</span><span class="p">[</span><span class="s1">&#39;__module__&#39;</span><span class="p">]</span>
            <span class="ow">and</span> <span class="s1">&#39;__qualname__&#39;</span> <span class="ow">in</span> <span class="n">namespace</span>
            <span class="ow">and</span> <span class="n">value</span><span class="o">.</span><span class="vm">__qualname__</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">namespace</span><span class="p">[</span><span class="s1">&#39;__qualname__&#39;</span><span class="p">])</span>
        <span class="p">):</span>
            <span class="c1"># `value` is a nested type defined in this namespace; don&#39;t error</span>
            <span class="k">continue</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">all_ignored_types</span><span class="p">)</span> <span class="ow">or</span> <span class="n">value</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">==</span> <span class="s1">&#39;functools&#39;</span><span class="p">:</span>
            <span class="n">ignored_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">var_name</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ModelPrivateAttr</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">var_name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;__&#39;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span>
                    <span class="s1">&#39;Private attributes must not use dunder names;&#39;</span>
                    <span class="sa">f</span><span class="s1">&#39; use a single underscore prefix instead of </span><span class="si">{</span><span class="n">var_name</span><span class="si">!r}</span><span class="s1">.&#39;</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">is_valid_field_name</span><span class="p">(</span><span class="n">var_name</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span>
                    <span class="s1">&#39;Private attributes must not use valid field names;&#39;</span>
                    <span class="sa">f</span><span class="s1">&#39; use sunder names, e.g. </span><span class="si">{</span><span class="s2">&quot;_&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">var_name</span><span class="si">!r}</span><span class="s1"> instead of </span><span class="si">{</span><span class="n">var_name</span><span class="si">!r}</span><span class="s1">.&#39;</span>
                <span class="p">)</span>
            <span class="n">private_attributes</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">del</span> <span class="n">namespace</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">FieldInfo</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_valid_field_name</span><span class="p">(</span><span class="n">var_name</span><span class="p">):</span>
            <span class="n">suggested_name</span> <span class="o">=</span> <span class="n">var_name</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="s1">&#39;my_field&#39;</span>  <span class="c1"># don&#39;t suggest &#39;&#39; for all-underscore name</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;Fields must not use names with leading underscores;&#39;</span>
                <span class="sa">f</span><span class="s1">&#39; e.g., use </span><span class="si">{</span><span class="n">suggested_name</span><span class="si">!r}</span><span class="s1"> instead of </span><span class="si">{</span><span class="n">var_name</span><span class="si">!r}</span><span class="s1">.&#39;</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="n">var_name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;__&#39;</span><span class="p">):</span>
            <span class="k">continue</span>
        <span class="k">elif</span> <span class="n">is_valid_privateattr_name</span><span class="p">(</span><span class="n">var_name</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">var_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">raw_annotations</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">is_classvar</span><span class="p">(</span><span class="n">raw_annotations</span><span class="p">[</span><span class="n">var_name</span><span class="p">]):</span>
                <span class="n">private_attributes</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">PrivateAttr</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
                <span class="k">del</span> <span class="n">namespace</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">var_name</span> <span class="ow">in</span> <span class="n">base_class_vars</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">elif</span> <span class="n">var_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">raw_annotations</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">var_name</span> <span class="ow">in</span> <span class="n">base_class_fields</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">PydanticUserError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;Field </span><span class="si">{</span><span class="n">var_name</span><span class="si">!r}</span><span class="s1"> defined on a base class was overridden by a non-annotated attribute. &#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;All field definitions, including overrides, require a type annotation.&#39;</span><span class="p">,</span>
                    <span class="n">code</span><span class="o">=</span><span class="s1">&#39;model-field-overridden&#39;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">FieldInfo</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">PydanticUserError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;Field </span><span class="si">{</span><span class="n">var_name</span><span class="si">!r}</span><span class="s1"> requires a type annotation&#39;</span><span class="p">,</span> <span class="n">code</span><span class="o">=</span><span class="s1">&#39;model-field-missing-annotation&#39;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">PydanticUserError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;A non-annotated attribute was detected: `</span><span class="si">{</span><span class="n">var_name</span><span class="si">}</span><span class="s1"> = </span><span class="si">{</span><span class="n">value</span><span class="si">!r}</span><span class="s1">`. All model fields require a &#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;type annotation; if `</span><span class="si">{</span><span class="n">var_name</span><span class="si">}</span><span class="s1">` is not meant to be a field, you may be able to resolve this &#39;</span>
                    <span class="sa">f</span><span class="s2">&quot;error by annotating it as a `ClassVar` or updating `model_config[&#39;ignored_types&#39;]`.&quot;</span><span class="p">,</span>
                    <span class="n">code</span><span class="o">=</span><span class="s1">&#39;model-field-missing-annotation&#39;</span><span class="p">,</span>
                <span class="p">)</span>

    <span class="k">for</span> <span class="n">ann_name</span><span class="p">,</span> <span class="n">ann_type</span> <span class="ow">in</span> <span class="n">raw_annotations</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">is_valid_privateattr_name</span><span class="p">(</span><span class="n">ann_name</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">ann_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">private_attributes</span>
            <span class="ow">and</span> <span class="n">ann_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ignored_names</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_classvar</span><span class="p">(</span><span class="n">ann_type</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">ann_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_ignored_types</span>
            <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">ann_type</span><span class="p">,</span> <span class="s1">&#39;__module__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="o">!=</span> <span class="s1">&#39;functools&#39;</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="n">is_annotated</span><span class="p">(</span><span class="n">ann_type</span><span class="p">):</span>
                <span class="n">_</span><span class="p">,</span> <span class="o">*</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">typing_extensions</span><span class="o">.</span><span class="n">get_args</span><span class="p">(</span><span class="n">ann_type</span><span class="p">)</span>
                <span class="n">private_attr</span> <span class="o">=</span> <span class="nb">next</span><span class="p">((</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">metadata</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">ModelPrivateAttr</span><span class="p">)),</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">private_attr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">private_attributes</span><span class="p">[</span><span class="n">ann_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">private_attr</span>
                    <span class="k">continue</span>
            <span class="n">private_attributes</span><span class="p">[</span><span class="n">ann_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">PrivateAttr</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">private_attributes</span>


<span class="k">def</span> <span class="nf">set_default_hash_func</span><span class="p">(</span><span class="bp">cls</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">BaseModel</span><span class="p">],</span> <span class="n">bases</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">type</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="o">...</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">base_hash_func</span> <span class="o">=</span> <span class="n">get_attribute_from_bases</span><span class="p">(</span><span class="n">bases</span><span class="p">,</span> <span class="s1">&#39;__hash__&#39;</span><span class="p">)</span>
    <span class="n">new_hash_func</span> <span class="o">=</span> <span class="n">make_hash_func</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">base_hash_func</span> <span class="ow">in</span> <span class="p">{</span><span class="kc">None</span><span class="p">,</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">}</span> <span class="ow">or</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">base_hash_func</span><span class="p">,</span> <span class="s1">&#39;__code__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="o">==</span> <span class="n">new_hash_func</span><span class="o">.</span><span class="vm">__code__</span><span class="p">:</span>
        <span class="c1"># If `__hash__` is some default, we generate a hash function.</span>
        <span class="c1"># It will be `None` if not overridden from BaseModel.</span>
        <span class="c1"># It may be `object.__hash__` if there is another</span>
        <span class="c1"># parent class earlier in the bases which doesn&#39;t override `__hash__` (e.g. `typing.Generic`).</span>
        <span class="c1"># It may be a value set by `set_default_hash_func` if `cls` is a subclass of another frozen model.</span>
        <span class="c1"># In the last case we still need a new hash function to account for new `model_fields`.</span>
        <span class="bp">cls</span><span class="o">.</span><span class="fm">__hash__</span> <span class="o">=</span> <span class="n">new_hash_func</span>


<span class="k">def</span> <span class="nf">make_hash_func</span><span class="p">(</span><span class="bp">cls</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">BaseModel</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
    <span class="n">getter</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="o">*</span><span class="bp">cls</span><span class="o">.</span><span class="n">model_fields</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">model_fields</span> <span class="k">else</span> <span class="k">lambda</span> <span class="n">_</span><span class="p">:</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">hash_func</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="n">getter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># In rare cases (such as when using the deprecated copy method), the __dict__ may not contain</span>
            <span class="c1"># all model fields, which is how we can get here.</span>
            <span class="c1"># getter(self.__dict__) is much faster than any &#39;safe&#39; method that accounts for missing keys,</span>
            <span class="c1"># and wrapping it in a `try` doesn&#39;t slow things down much in the common case.</span>
            <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="n">getter</span><span class="p">(</span><span class="n">SafeGetItemProxy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)))</span>

    <span class="k">return</span> <span class="n">hash_func</span>


<span class="k">def</span> <span class="nf">set_model_fields</span><span class="p">(</span>
    <span class="bp">cls</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">BaseModel</span><span class="p">],</span> <span class="n">bases</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">type</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="o">...</span><span class="p">],</span> <span class="n">config_wrapper</span><span class="p">:</span> <span class="n">ConfigWrapper</span><span class="p">,</span> <span class="n">types_namespace</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Collect and set `cls.model_fields` and `cls.__class_vars__`.</span>

<span class="sd">    Args:</span>
<span class="sd">        cls: BaseModel or dataclass.</span>
<span class="sd">        bases: Parents of the class, generally `cls.__bases__`.</span>
<span class="sd">        config_wrapper: The config wrapper instance.</span>
<span class="sd">        types_namespace: Optional extra namespace to look for types in.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">typevars_map</span> <span class="o">=</span> <span class="n">get_model_typevars_map</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
    <span class="n">fields</span><span class="p">,</span> <span class="n">class_vars</span> <span class="o">=</span> <span class="n">collect_model_fields</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">config_wrapper</span><span class="p">,</span> <span class="n">types_namespace</span><span class="p">,</span> <span class="n">typevars_map</span><span class="o">=</span><span class="n">typevars_map</span><span class="p">)</span>

    <span class="bp">cls</span><span class="o">.</span><span class="n">model_fields</span> <span class="o">=</span> <span class="n">fields</span>
    <span class="bp">cls</span><span class="o">.</span><span class="n">__class_vars__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">class_vars</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">class_vars</span><span class="p">:</span>
        <span class="c1"># Class vars should not be private attributes</span>
        <span class="c1">#     We remove them _here_ and not earlier because we rely on inspecting the class to determine its classvars,</span>
        <span class="c1">#     but private attributes are determined by inspecting the namespace _prior_ to class creation.</span>
        <span class="c1">#     In the case that a classvar with a leading-&#39;_&#39; is defined via a ForwardRef (e.g., when using</span>
        <span class="c1">#     `__future__.annotations`), we want to remove the private attribute which was detected _before_ we knew it</span>
        <span class="c1">#     evaluated to a classvar</span>

        <span class="n">value</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__private_attributes__</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">value</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">PydanticUndefined</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">default</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">complete_model_class</span><span class="p">(</span>
    <span class="bp">cls</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">BaseModel</span><span class="p">],</span>
    <span class="n">cls_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">config_wrapper</span><span class="p">:</span> <span class="n">ConfigWrapper</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">raise_errors</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">types_namespace</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">create_model_module</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Finish building a model class.</span>

<span class="sd">    This logic must be called after class has been created since validation functions must be bound</span>
<span class="sd">    and `get_type_hints` requires a class object.</span>

<span class="sd">    Args:</span>
<span class="sd">        cls: BaseModel or dataclass.</span>
<span class="sd">        cls_name: The model or dataclass name.</span>
<span class="sd">        config_wrapper: The config wrapper instance.</span>
<span class="sd">        raise_errors: Whether to raise errors.</span>
<span class="sd">        types_namespace: Optional extra namespace to look for types in.</span>
<span class="sd">        create_model_module: The module of the class to be created, if created by `create_model`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        `True` if the model is successfully completed, else `False`.</span>

<span class="sd">    Raises:</span>
<span class="sd">        PydanticUndefinedAnnotation: If `PydanticUndefinedAnnotation` occurs in`__get_pydantic_core_schema__`</span>
<span class="sd">            and `raise_errors=True`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">typevars_map</span> <span class="o">=</span> <span class="n">get_model_typevars_map</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
    <span class="n">gen_schema</span> <span class="o">=</span> <span class="n">GenerateSchema</span><span class="p">(</span>
        <span class="n">config_wrapper</span><span class="p">,</span>
        <span class="n">types_namespace</span><span class="p">,</span>
        <span class="n">typevars_map</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">handler</span> <span class="o">=</span> <span class="n">CallbackGetCoreSchemaHandler</span><span class="p">(</span>
        <span class="n">partial</span><span class="p">(</span><span class="n">gen_schema</span><span class="o">.</span><span class="n">generate_schema</span><span class="p">,</span> <span class="n">from_dunder_get_core_schema</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
        <span class="n">gen_schema</span><span class="p">,</span>
        <span class="n">ref_mode</span><span class="o">=</span><span class="s1">&#39;unpack&#39;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">config_wrapper</span><span class="o">.</span><span class="n">defer_build</span><span class="p">:</span>
        <span class="n">set_model_mocks</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">cls_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">schema</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__get_pydantic_core_schema__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">handler</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">PydanticUndefinedAnnotation</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">raise_errors</span><span class="p">:</span>
            <span class="k">raise</span>
        <span class="n">set_model_mocks</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">cls_name</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;`</span><span class="si">{</span><span class="n">e</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">`&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="n">core_config</span> <span class="o">=</span> <span class="n">config_wrapper</span><span class="o">.</span><span class="n">core_config</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">schema</span> <span class="o">=</span> <span class="n">gen_schema</span><span class="o">.</span><span class="n">clean_schema</span><span class="p">(</span><span class="n">schema</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">gen_schema</span><span class="o">.</span><span class="n">CollectedInvalid</span><span class="p">:</span>
        <span class="n">set_model_mocks</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">cls_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># debug(schema)</span>
    <span class="bp">cls</span><span class="o">.</span><span class="n">__pydantic_core_schema__</span> <span class="o">=</span> <span class="n">schema</span>

    <span class="bp">cls</span><span class="o">.</span><span class="n">__pydantic_validator__</span> <span class="o">=</span> <span class="n">create_schema_validator</span><span class="p">(</span>
        <span class="n">schema</span><span class="p">,</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">create_model_module</span> <span class="ow">or</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__module__</span><span class="p">,</span>
        <span class="bp">cls</span><span class="o">.</span><span class="vm">__qualname__</span><span class="p">,</span>
        <span class="s1">&#39;create_model&#39;</span> <span class="k">if</span> <span class="n">create_model_module</span> <span class="k">else</span> <span class="s1">&#39;BaseModel&#39;</span><span class="p">,</span>
        <span class="n">core_config</span><span class="p">,</span>
        <span class="n">config_wrapper</span><span class="o">.</span><span class="n">plugin_settings</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="bp">cls</span><span class="o">.</span><span class="n">__pydantic_serializer__</span> <span class="o">=</span> <span class="n">SchemaSerializer</span><span class="p">(</span><span class="n">schema</span><span class="p">,</span> <span class="n">core_config</span><span class="p">)</span>
    <span class="bp">cls</span><span class="o">.</span><span class="n">__pydantic_complete__</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># set __signature__ attr only for model class, but not for its instances</span>
    <span class="bp">cls</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="n">ClassAttribute</span><span class="p">(</span>
        <span class="s1">&#39;__signature__&#39;</span><span class="p">,</span>
        <span class="n">generate_pydantic_signature</span><span class="p">(</span><span class="n">init</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="fm">__init__</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="n">model_fields</span><span class="p">,</span> <span class="n">config_wrapper</span><span class="o">=</span><span class="n">config_wrapper</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="kc">True</span>


<span class="k">def</span> <span class="nf">set_deprecated_descriptors</span><span class="p">(</span><span class="bp">cls</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">BaseModel</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Set data descriptors on the class for deprecated fields.&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">field_info</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">model_fields</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">msg</span> <span class="o">:=</span> <span class="n">field_info</span><span class="o">.</span><span class="n">deprecation_message</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">desc</span> <span class="o">=</span> <span class="n">_DeprecatedFieldDescriptor</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">desc</span><span class="o">.</span><span class="n">__set_name__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">field</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">desc</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">computed_field_info</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">model_computed_fields</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">msg</span> <span class="o">:=</span> <span class="n">computed_field_info</span><span class="o">.</span><span class="n">deprecation_message</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="c1"># Avoid having two warnings emitted:</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">unwrap_wrapped_function</span><span class="p">(</span><span class="n">computed_field_info</span><span class="o">.</span><span class="n">wrapped_property</span><span class="p">),</span> <span class="s1">&#39;__deprecated__&#39;</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">desc</span> <span class="o">=</span> <span class="n">_DeprecatedFieldDescriptor</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">computed_field_info</span><span class="o">.</span><span class="n">wrapped_property</span><span class="p">)</span>
            <span class="n">desc</span><span class="o">.</span><span class="n">__set_name__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">field</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">desc</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_DeprecatedFieldDescriptor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Data descriptor used to emit a runtime deprecation warning before accessing a deprecated field.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        msg: The deprecation message to be emitted.</span>
<span class="sd">        wrapped_property: The property instance if the deprecated field is a computed field, or `None`.</span>
<span class="sd">        field_name: The name of the field being deprecated.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">field_name</span><span class="p">:</span> <span class="nb">str</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">wrapped_property</span><span class="p">:</span> <span class="nb">property</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wrapped_property</span> <span class="o">=</span> <span class="n">wrapped_property</span>

    <span class="k">def</span> <span class="nf">__set_name__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">cls</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">BaseModel</span><span class="p">],</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">field_name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">:</span> <span class="n">BaseModel</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">BaseModel</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">field_name</span><span class="p">)</span>

        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msg</span><span class="p">,</span> <span class="n">builtins</span><span class="o">.</span><span class="n">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped_property</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrapped_property</span><span class="o">.</span><span class="fm">__get__</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">field_name</span><span class="p">]</span>

    <span class="c1"># Defined to take precedence over the instance&#39;s dictionary</span>
    <span class="c1"># Note that it will not be called when setting a value on a model instance</span>
    <span class="c1"># as `BaseModel.__setattr__` is defined and takes priority.</span>
    <span class="k">def</span> <span class="fm">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NoReturn</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">field_name</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_PydanticWeakRef</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Wrapper for `weakref.ref` that enables `pickle` serialization.</span>

<span class="sd">    Cloudpickle fails to serialize `weakref.ref` objects due to an arcane error related</span>
<span class="sd">    to abstract base classes (`abc.ABC`). This class works around the issue by wrapping</span>
<span class="sd">    `weakref.ref` instead of subclassing it.</span>

<span class="sd">    See https://github.com/pydantic/pydantic/issues/6763 for context.</span>

<span class="sd">    Semantics:</span>
<span class="sd">        - If not pickled, behaves the same as a `weakref.ref`.</span>
<span class="sd">        - If pickled along with the referenced object, the same `weakref.ref` behavior</span>
<span class="sd">          will be maintained between them after unpickling.</span>
<span class="sd">        - If pickled without the referenced object, after unpickling the underlying</span>
<span class="sd">          reference will be cleared (`__call__` will always return `None`).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">:</span> <span class="n">Any</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># The object will be `None` upon deserialization if the serialized weakref</span>
            <span class="c1"># had lost its underlying object.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_wr</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_wr</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wr</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Callable</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">weakref</span><span class="o">.</span><span class="n">ReferenceType</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]]:</span>
        <span class="k">return</span> <span class="n">_PydanticWeakRef</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="p">(),)</span>


<span class="k">def</span> <span class="nf">build_lenient_weakvaluedict</span><span class="p">(</span><span class="n">d</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Takes an input dictionary, and produces a new value that (invertibly) replaces the values with weakrefs.</span>

<span class="sd">    We can&#39;t just use a WeakValueDictionary because many types (including int, str, etc.) can&#39;t be stored as values</span>
<span class="sd">    in a WeakValueDictionary.</span>

<span class="sd">    The `unpack_lenient_weakvaluedict` function can be used to reverse this operation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">proxy</span> <span class="o">=</span> <span class="n">_PydanticWeakRef</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">proxy</span> <span class="o">=</span> <span class="n">v</span>
        <span class="n">result</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">proxy</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">unpack_lenient_weakvaluedict</span><span class="p">(</span><span class="n">d</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Inverts the transform performed by `build_lenient_weakvaluedict`.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">_PydanticWeakRef</span><span class="p">):</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">default_ignored_types</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">type</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="o">...</span><span class="p">]:</span>
    <span class="kn">from</span> <span class="nn">..fields</span> <span class="kn">import</span> <span class="n">ComputedFieldInfo</span>

    <span class="k">return</span> <span class="p">(</span>
        <span class="n">FunctionType</span><span class="p">,</span>
        <span class="nb">property</span><span class="p">,</span>
        <span class="nb">classmethod</span><span class="p">,</span>
        <span class="nb">staticmethod</span><span class="p">,</span>
        <span class="n">PydanticDescriptorProxy</span><span class="p">,</span>
        <span class="n">ComputedFieldInfo</span><span class="p">,</span>
        <span class="n">ValidateCallWrapper</span><span class="p">,</span>
    <span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Utah State University.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>